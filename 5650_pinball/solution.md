## Basic idea
모든 벽, 웜홀에 대해 최대 길이 path 찾아 놓는다 (N^2). 모두 수직 벽면 1 - 수직 벽면 2 - 수직 벽면 1 또는 블랙홀 - 수직 벽면 1 - 블랙홀 또는 블랙홀 - 블랙홀 형태 또는 수직 벽면이나 블랙홀 만나지 않는 cycle 형태. 각 형태에서 optimal 출발 지점을 찾는다. 그러고서 각 path 중에서 최대 점수를 찾으면 그게 답.

### Time complexity
O(N^2^)

### Possible paths
- 블랙홀 - 블랙홀
- 블랙홀1 - 수직 벽면 1 - 블랙홀1
- 수직 벽면 1 - 수직 벽면 2 - 수직 벽면 1
- 블록 1 - 블록 2- 블록 3- … - 블록 1 - 블록 2 - .. (수직 반사 없이)

마지막 경우를 제외하고 모두 어디서 시작해야 다음 수직 벽면 or 블랙홀 까지 갈 수 있는가? 가 문제다. 아예 다음 수직 벽면 or 블랙홀 까지 도달하기 전에 자신의 출발 지점으로 되돌아올 수 밖에 없는 경로가 있을 수도 있다. 따라서 위 세 경우도 결국 같은 방식으로 풀어야 한다는 사실을 알 수 있다.
각 경로에서 수직 벽면 1 또는 블랙홀 부터 시작하여, 공이 진행한다고 가정하고 매 칸마다 지나온 블럭 또는 벽의 수를 기록한다 [1]. 그러다 보면 지나온 블럭에 적어야 할 때가 있는데 (출발 지점 다시 지나는 경우), 블럭에 값을 overwrite 하고, 지금까지 경험한 이런 경우 중 최대 점수를 업데이트 한다 (만약 기존 최대 점수보다 크다면). 이렇게 하다 보면 결국 수직 벽면 2 또는 다음 블랙홀에 도달하게 되고, 이제 다시 처음 벽면 또는 블랙홀로 가서 경로에 쓰인 값들을 훑어본다. overwrite되지 않은 (즉 현재 지나온 벽 수와 동일한 값을 가진) 첫 block을 만날 경우, 거기서부터 시작해서 다시 거기로 돌아오는 경우의 점수와, 아까 기록해 둔 최대 점수와 비교해보고 더 큰 것을 찾으면, 그 점수가 해당 path (벽면 1 또는 시작 블랙홀에서 시작한 경우) 에서 얻을 수 있는 최대 점수. 반대로 수직 벽면 2에서 시작한 경우도 해보고, 두 경우 중 점수가 가장 큰 게 해당 path에서의 최대 점수 [2]. 이제 이 점수를 global 최대 점수 [3] 와 비교하여 update.

첫 세 경우를 다 찾고 난 뒤에도 지나가지 않은 경로가 있다면, 마지막 경우가 존재한다는 뜻이다. 따라서 첫 세 경우만 먼저 고려하여 한 바퀴 돌고, 뒤에 한 번 더 돌아서 4번째 경우를 찾아서 해결하자.

## 총 필요한 자료구조
- map array
	- input map array
	- path block마다 임시로 현재 점수 기록하는 array [1]
	- 위 [1]의 array와 연동되어, 각 점수가 어떤 id의 path에 의해 적혔는지 기록하는 array
	- path check 완료된 block, wall, blackhole 기록하는 array

- path 내 임시 점수 기록
	- 현재 path의 최대 점수 [2]

- global 점수 기록
	- 지금까지 고려한 모든 path에서 발견한 가장 큰 점수 [3]

